# test


# IP Reporter 监控系统 - 安装与使用说明

欢迎使用 IP Reporter 监控系统！本系统旨在帮助您轻松监控和管理多个服务器节点的IP质量。本文档将引导您完成主控端和客户端的安装、配置及日常使用。

## 目录

1.  [系统架构](#1-系统架构)
2.  [环境要求](#2-环境要求)
3.  [安装步骤](#3-安装步骤)
    -   [3.1 安装主控端 (Server)](#31-安装主控端-server)
    -   [3.2 获取主控通讯密钥 (SERVER_SECRET_KEY)](#32-获取主控通讯密钥-server_secret_key)
    -   [3.3 安装客户端 (Client)](#33-安装客户端-client)
4.  [使用说明](#4-使用说明)
    -   [4.1 访问管理面板](#41-访问管理面板)
    -   [4.2 面板功能介绍](#42-面板功能介绍)
5.  [常见问题 (FAQ)](#5-常见问题-faq)
6.  [技术说明](#技术说明)
## 1. 系统架构

本系统由两部分组成：

-   **主控端 (Server)**: 安装在一台中央服务器上，用于汇总所有节点的IP报告，并提供Web管理界面。
-   **客户端 (Client)**: 安装在您需要监控的每一台服务器（节点）上，负责执行检测并上报数据。

您需要**先安装主控端**，然后用主控端生成的密钥去**安装一个或多个客户端**。

## 2. 环境要求

-   **操作系统**: 推荐使用 Debian 10/11/12 或 Ubuntu 18.04/20.04/22.04 的 64 位版本。
-   **用户权限**: 安装过程需要 `root` 用户权限。
-   **网络**:
    -   主控端服务器需要有一个公网IP，并确保防火墙（包括云服务商的安全组）开放了您计划用于Web访问的端口（默认为 `28037`）。
    -   客户端服务器需要能够访问互联网，以便执行检测脚本。
    -   客户端服务器需要能够访问主控端的 `28037` 端口，以便上报数据。

## 3. 安装步骤

我们使用一个统一的管理脚本 `manager.sh` 来简化所有安装和管理操作。

### 3.1 安装主控端 (Server)

在您选定的**主控端服务器**上，以 `root` 用户身份执行以下命令：

```bash
bash <(curl -sL https://raw.githubusercontent.com/ClaraCora/test/main/manager.sh)
```

脚本运行后，会出现一个菜单。请按以下步骤操作：

1.  在主菜单中，输入 `1` 并按回车，选择 **“安装主控端 (Server)”**。
2.  脚本会自动安装Python、创建虚拟环境、下载所有必需的文件，并设置 systemd 服务。
3.  安装过程大约需要1-2分钟。安装完成后，脚本会自动启动主控端服务，并显示服务的运行状态。如果看到绿色的 `active (running)`，则表示主控端已成功启动。

**首次启动时，脚本会自动在 `/opt/main-server/src/` 目录下生成一个 `server-config.json` 配置文件，其中包含了所有必需的密钥和默认的管理员账户。**

### 3.2 获取主控通讯密钥 (SERVER_SECRET_KEY)

客户端在安装时，需要这个密钥来与主控端进行安全通信。请在**主控端服务器**上，通过以下任一方法获取：

#### 方法一：通过管理脚本获取 (推荐)

1.  再次运行管理脚本：
    ```bash
    bash <(curl -sL https://raw.githubusercontent.com/ClaraCora/test/main/manager.sh)
    ```
2.  在主菜单中，输入 `3` 并按回车，进入 **“管理已安装的主控端”**。
3.  在管理菜单中，输入 `4` 并按回车，选择 **“查询通讯密钥”**。
4.  脚本会自动读取配置文件并显示密钥。它看起来像一个UUID，例如 `xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`。
5.  **请复制并妥善保管这个密钥**，下一步安装客户端时会用到。

#### 方法二：手动查看配置文件

直接查看 `server-config.json` 文件：

```bash
cat /opt/main-server/src/server-config.json
```

在输出的内容中，找到 `"SERVER_SECRET_KEY"` 字段，其对应的值就是您需要的密钥。

### 3.3 安装客户端 (Client)

现在，登录到您需要监控的**每一台客户端服务器**上，以 `root` 用户身份执行以下命令：

```bash
bash <(curl -sL https://raw.githubusercontent.com/ClaraCora/test/main/manager.sh)
```

1.  在主菜单中，输入 `2` 并按回车，选择 **“安装客户端 (Client)”**。
2.  脚本会进入一个交互式的配置流程，请根据提示输入以下信息：
    -   **请输入主控端IP或域名**: 输入您主控端服务器的公网IP地址或域名。
    -   **请输入主控端端口**: 如果您没有修改过主控端配置，直接按回车使用默认端口 `28037` 即可。
    -   **请输入主控通讯密钥**: **粘贴您在上一步中获取的 `SERVER_SECRET_KEY`**。
3.  输入完毕后，脚本会自动完成剩余的安装、配置和启动步骤。
4.  安装完成后，客户端会立即执行一次IP检测并上报给主控端。

对您需要监控的每一台服务器，重复以上客户端安装步骤。

## 4. 使用说明

### 4.1 访问管理面板

-   **访客面板**: `http://<你的主控端IP>:28037/`
    -   此页面公开可见，用于展示所有节点的IP质量报告，但没有任何管理操作。
-   **管理员面板**: `http://<你的主控端IP>:28037/cadmin`
    -   访问此页面时，浏览器会弹出一个登录框。
    -   **默认用户名**: `admin`
    -   **默认密码**: `password`
    -   **强烈建议**: 首次登录后，请立即在主控端服务器上编辑 `/opt/main-server/src/server-config.json` 文件，修改 `ADMIN_USER` 和 `ADMIN_PASS` 为更安全的值，然后执行 `systemctl restart main-server` 重启服务。

### 4.2 面板功能介绍

管理员面板提供了丰富的功能：

-   **排序**: 点击顶部的“按编号”、“按时间”、“按IP”按钮，可以对节点列表进行排序。
-   **过滤**: 点击地区按钮，可以只显示特定地区的节点。
-   **设置备注/编号**: 在每个节点的第一列，您可以输入备注和用于排序的数字编号，然后点击“保存”。
-   **马上重测**: 点击此按钮会立即向客户端发送指令，要求它重新执行IP检测并上报最新数据。此过程是异步的，页面不会卡顿，按钮会进入倒计时。
-   **删除记录**: 从主控端的数据库中永久删除该节点的记录。

## 5. 常见问题 (FAQ)

-   **Q: 点击“马上重测”后提示连接客户端失败？**
    -   **A:** 请检查：1. 主控端服务器的防火墙（安全组）是否允许出站流量。2. 客户端服务器的防火墙（安全组）是否允许来自主控端IP对 `37028` 端口的入站访问。

-   **Q: 客户端状态一直显示“执行失败”怎么办？**
    -   **A:** 主控端的自动重测功能会每10分钟尝试恢复它。如果长时间失败，请登录到**客户端服务器**，执行 `journalctl -u ip-reporter -f` 查看详细的错误日志。最常见的原因是客户端无法访问 `IP.Check.Place` 网站。

-   **Q: 如何更新主控端或客户端的程序？**
    -   **A:** 在对应的服务器上运行 `manager.sh` 脚本，进入管理菜单，选择“更新”选项即可。



## 技术说明<a name="技术说明"></a>
# IP Reporter 监控系统 v2.1 - 技术说明文档

**版本日期**: 2025年7月31日

## 1. 系统概述

IP Reporter 监控系统是一套C/S（客户端/服务器）架构的解决方案，旨在自动化地、周期性地检测服务器节点的IP质量，并将结果汇总到一台中央主控服务器进行统一展示和管理。

- **客户端 (Client)**: 部署在需要被监控的各个服务器节点上。它是一个轻量级的Python Flask应用，负责执行IP质量检测脚本、接收主控端的指令，并安全地将检测报告上报。
- **主控端 (Server)**: 部署在一台中央服务器上。它也是一个Python Flask应用，负责接收并存储所有客户端的报告、提供一个功能丰富的Web管理界面，并能向指定客户端下发指令。

## 2. v2.1 版本核心功能列表

- **高强度安全通信**: 客户端与主控端之间所有的数据上报均采用 **HMAC-SHA256** 请求签名，杜绝数据篡改和未授权上报。
- **管理员权限控制**: 管理后台 (`/cadmin`) 采用 **HTTP基础认证**，保护所有管理操作。
- **异步前端交互**: 管理后台的“马上重测”功能采用 **AJAX** 实现，点击后页面**不会锁定或“转圈圈”**，提供流畅的用户体验。
- **防重复点击机制**: “马上重测”按钮在点击后会进入**160秒倒计时**，并禁用按钮（屏蔽罩），防止用户重复发送指令。
- **失败节点自动重测**: 主控端内置一个后台健康检查线程，**每10分钟**自动扫描状态为“执行失败”的节点，并向其发送重测指令，实现自动运维。
- **自定义排序与备注**: 支持为每个节点设置**备注**和自定义的**机器编号**，并可以按编号、上报时间或IP地址进行排序。
- **精确的数据清洗与验证**: 对上报数据中可能包含的ANSI颜色代码进行**精确过滤和验证**，确保前端只显示有效的两位大写国家代码。

## 3. 核心实现逻辑

### 3.1 主控端 (`server.py`) 逻辑

主控端是整个系统的中枢，负责数据汇总、安全验证、用户交互和指令下发。

1.  **数据接收与安全 (`/report` 路由)**:
    -   这是接收所有客户端上报数据的唯一入口。
    -   **安全核心**: 此接口受下文详述的 **HMAC签名机制** 保护。服务器会使用客户端提供的密钥和原始请求体，在本地重新计算签名，并与客户端发来的签名进行安全比较。同时检查时间戳以防止重放攻击。

2.  **数据处理与清洗 (`process_clients_data` 函数)**:
    -   从数据库取出原始JSON报告后，此函数负责解析和“美化”数据。
    -   **清洗逻辑**: 针对流媒体解锁地区（如 `\u001b[31mCN\u001b[32m`）的字段，执行以下三步操作：
        1.  **过滤**: 只保留字符串中的大写英文字母。
        2.  **验证**: 检查结果是否为**2个字符**，并且是否存在于一个预定义的有效国家代码列表 (`VALID_COUNTRY_CODES`) 中。
        3.  **回退**: 如果验证失败，则将该字段值设为 `N/A`，确保前端显示的整洁性。
    -   **错误识别**: 能够智能判断报告是成功还是失败（通过 `ASN: "ERROR"` 字段），以便在前端进行差异化展示。

3.  **自动运维 (`health_checker` 线程)**:
    -   程序启动时，会创建一个独立的**后台守护线程**。
    -   该线程每10分钟 (`time.sleep(600)`) 被唤醒一次。
    -   它会查询数据库中所有状态为“执行失败”的客户端，并调用内部重测函数 `trigger_retest_internal` 逐个向它们发送重测指令，并在日志中记录操作。

4.  **前端交互 (`/trigger_retest` 等路由)**:
    -   所有管理员操作的路由都由 `@requires_auth` 装饰器保护。
    -   `/trigger_retest` 路由被设计为处理 **AJAX** 请求。它向客户端发送指令后，无论成功或失败，都会返回一个**JSON格式**的响应给前端JavaScript，而不是重定向页面。
    -   `/update_remark` 和 `/update_machine_id` 等路由则处理传统的表单提交，通过 `flash` 消息和页面重定向来反馈结果。

### 3.2 客户端 (`client.py`) 逻辑

客户端的设计遵循“接收指令、后台执行、异步上报”的核心原则。

1.  **指令响应 (`/retest` 路由)**:
    -   这是客户端与主控端交互的核心接口。
    -   **异步任务核心**: 为了避免在处理HTTP请求的主线程中执行长时间的阻塞任务（这会导致进程死锁或静默失败），此路由的逻辑被设计为：
        1.  验证来自主控端的密钥 (`X-Server-Key`)。
        2.  **立即启动一个新的后台线程**去执行完整的检测和上报任务 (`run_and_report_task`)。
        3.  **立刻返回一个 `202 Accepted` 响应**给主控端，表示“指令已收到，正在后台处理”，而不会等待任务完成。这个设计是系统稳定运行的关键。

2.  **IP质量检测 (`run_ip_check`)**:
    -   通过 `subprocess.run` 调用外部bash命令。
    -   **编码修复**: 执行命令时强制指定了 `LC_ALL=C.UTF-8` 环境，以解决中文乱码问题。
    -   **健壮性**: 无论外部脚本成功、失败还是超时，此函数都会确保生成一个**格式正确的 `data.json` 文件**，从而保证后续流程总能处理有效数据。

## 4. HMAC签名加密机制详解

系统采用 **HMAC-SHA256** 请求签名机制，确保了数据的**完整性**（未被篡改）和**来源真实性**（来自合法的客户端）。

#### 4.1 加密流程 (在客户端)

1.  **准备数据**: 将完整的报告JSON序列化为一个紧凑且键排序的字符串 (`body`)。
2.  **构建消息**: 获取当前Unix时间戳 (`timestamp`)，并与 `body` 用 `.` 连接，形成待签名的原始消息，格式为：`"timestamp.body"`。
3.  **生成签名**: 使用客户端独有的 `client_key` 作为密钥，通过HMAC-SHA256算法计算出消息的哈希值，即为签名 (`signature`)。
4.  **发送请求**: 在HTTP请求头中，附带 `X-Client-Key` 和 `X-Signature` (包含时间戳和签名)。

#### 4.2 验证流程 (在主控端)

1.  **接收数据**: 从请求头中解析出 `client_key`、`timestamp` 和客户端生成的 `client_signature`。获取原始请求体 `body`。
2.  **防重放攻击**: 检查 `timestamp` 是否在有效时间窗口内（300秒），防止旧请求被重复利用。
3.  **重新计算签名**: 服务器使用收到的 `client_key`、`timestamp` 和 `body`，通过**完全相同的HMAC-SHA256算法**，在本地计算出一个 `server_signature`。
4.  **安全比较**: 使用 `hmac.compare_digest` 函数（可防止时序攻击）来比较 `server_signature` 和 `client_signature`。只有两者完全一致，验证才算通过。

---

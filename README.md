# test

交互安装命令
```bash
bash <(curl -Ls https://raw.githubusercontent.com/ClaraCora/test/refs/heads/main/manager.sh)
```
# IP Reporter 监控系统 v2.1 - 技术说明文档

**版本日期**: 2025年7月31日

## 1. 系统概述

IP Reporter 监控系统是一套C/S（客户端/服务器）架构的解决方案，旨在自动化地、周期性地检测服务器节点的IP质量，并将结果汇总到一台中央主控服务器进行统一展示和管理。

- **客户端 (Client)**: 部署在需要被监控的各个服务器节点上。它是一个轻量级的Python Flask应用，负责执行IP质量检测脚本、接收主控端的指令，并安全地将检测报告上报。
- **主控端 (Server)**: 部署在一台中央服务器上。它也是一个Python Flask应用，负责接收并存储所有客户端的报告、提供一个功能丰富的Web管理界面，并能向指定客户端下发指令。

## 2. v2.1 版本核心功能列表

- **高强度安全通信**: 客户端与主控端之间所有的数据上报均采用 **HMAC-SHA256** 请求签名，杜绝数据篡改和未授权上报。
- **管理员权限控制**: 管理后台 (`/cadmin`) 采用 **HTTP基础认证**，保护所有管理操作。
- **异步前端交互**: 管理后台的“马上重测”功能采用 **AJAX** 实现，点击后页面**不会锁定或“转圈圈”**，提供流畅的用户体验。
- **防重复点击机制**: “马上重测”按钮在点击后会进入**160秒倒计时**，并禁用按钮（屏蔽罩），防止用户重复发送指令。
- **失败节点自动重测**: 主控端内置一个后台健康检查线程，**每10分钟**自动扫描状态为“执行失败”的节点，并向其发送重测指令，实现自动运维。
- **自定义排序与备注**: 支持为每个节点设置**备注**和自定义的**机器编号**，并可以按编号、上报时间或IP地址进行排序。
- **精确的数据清洗与验证**: 对上报数据中可能包含的ANSI颜色代码进行**精确过滤和验证**，确保前端只显示有效的两位大写国家代码。

## 3. 核心实现逻辑

### 3.1 主控端 (`server.py`) 逻辑

主控端是整个系统的中枢，负责数据汇总、安全验证、用户交互和指令下发。

1.  **数据接收与安全 (`/report` 路由)**:
    -   这是接收所有客户端上报数据的唯一入口。
    -   **安全核心**: 此接口受下文详述的 **HMAC签名机制** 保护。服务器会使用客户端提供的密钥和原始请求体，在本地重新计算签名，并与客户端发来的签名进行安全比较。同时检查时间戳以防止重放攻击。

2.  **数据处理与清洗 (`process_clients_data` 函数)**:
    -   从数据库取出原始JSON报告后，此函数负责解析和“美化”数据。
    -   **清洗逻辑**: 针对流媒体解锁地区（如 `\u001b[31mCN\u001b[32m`）的字段，执行以下三步操作：
        1.  **过滤**: 只保留字符串中的大写英文字母。
        2.  **验证**: 检查结果是否为**2个字符**，并且是否存在于一个预定义的有效国家代码列表 (`VALID_COUNTRY_CODES`) 中。
        3.  **回退**: 如果验证失败，则将该字段值设为 `N/A`，确保前端显示的整洁性。
    -   **错误识别**: 能够智能判断报告是成功还是失败（通过 `ASN: "ERROR"` 字段），以便在前端进行差异化展示。

3.  **自动运维 (`health_checker` 线程)**:
    -   程序启动时，会创建一个独立的**后台守护线程**。
    -   该线程每10分钟 (`time.sleep(600)`) 被唤醒一次。
    -   它会查询数据库中所有状态为“执行失败”的客户端，并调用内部重测函数 `trigger_retest_internal` 逐个向它们发送重测指令，并在日志中记录操作。

4.  **前端交互 (`/trigger_retest` 等路由)**:
    -   所有管理员操作的路由都由 `@requires_auth` 装饰器保护。
    -   `/trigger_retest` 路由被设计为处理 **AJAX** 请求。它向客户端发送指令后，无论成功或失败，都会返回一个**JSON格式**的响应给前端JavaScript，而不是重定向页面。
    -   `/update_remark` 和 `/update_machine_id` 等路由则处理传统的表单提交，通过 `flash` 消息和页面重定向来反馈结果。

### 3.2 客户端 (`client.py`) 逻辑

客户端的设计遵循“接收指令、后台执行、异步上报”的核心原则。

1.  **指令响应 (`/retest` 路由)**:
    -   这是客户端与主控端交互的核心接口。
    -   **异步任务核心**: 为了避免在处理HTTP请求的主线程中执行长时间的阻塞任务（这会导致进程死锁或静默失败），此路由的逻辑被设计为：
        1.  验证来自主控端的密钥 (`X-Server-Key`)。
        2.  **立即启动一个新的后台线程**去执行完整的检测和上报任务 (`run_and_report_task`)。
        3.  **立刻返回一个 `202 Accepted` 响应**给主控端，表示“指令已收到，正在后台处理”，而不会等待任务完成。这个设计是系统稳定运行的关键。

2.  **IP质量检测 (`run_ip_check`)**:
    -   通过 `subprocess.run` 调用外部bash命令。
    -   **编码修复**: 执行命令时强制指定了 `LC_ALL=C.UTF-8` 环境，以解决中文乱码问题。
    -   **健壮性**: 无论外部脚本成功、失败还是超时，此函数都会确保生成一个**格式正确的 `data.json` 文件**，从而保证后续流程总能处理有效数据。

## 4. HMAC签名加密机制详解

系统采用 **HMAC-SHA256** 请求签名机制，确保了数据的**完整性**（未被篡改）和**来源真实性**（来自合法的客户端）。

#### 4.1 加密流程 (在客户端)

1.  **准备数据**: 将完整的报告JSON序列化为一个紧凑且键排序的字符串 (`body`)。
2.  **构建消息**: 获取当前Unix时间戳 (`timestamp`)，并与 `body` 用 `.` 连接，形成待签名的原始消息，格式为：`"timestamp.body"`。
3.  **生成签名**: 使用客户端独有的 `client_key` 作为密钥，通过HMAC-SHA256算法计算出消息的哈希值，即为签名 (`signature`)。
4.  **发送请求**: 在HTTP请求头中，附带 `X-Client-Key` 和 `X-Signature` (包含时间戳和签名)。

#### 4.2 验证流程 (在主控端)

1.  **接收数据**: 从请求头中解析出 `client_key`、`timestamp` 和客户端生成的 `client_signature`。获取原始请求体 `body`。
2.  **防重放攻击**: 检查 `timestamp` 是否在有效时间窗口内（300秒），防止旧请求被重复利用。
3.  **重新计算签名**: 服务器使用收到的 `client_key`、`timestamp` 和 `body`，通过**完全相同的HMAC-SHA256算法**，在本地计算出一个 `server_signature`。
4.  **安全比较**: 使用 `hmac.compare_digest` 函数（可防止时序攻击）来比较 `server_signature` 和 `client_signature`。只有两者完全一致，验证才算通过。

---
